<%- include("settings/header") %>
<%- include("settings/nav") %>
<%- include("settings/top") %>

<style>
#chat-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
}
#messages {
  flex: 1;
  overflow-y: scroll;
  padding: 10px;
  width: 100%;
  box-sizing: border-box;
  background: #fafafa;
}
.message-bubble {
  background-color: #e1faff;
  padding: 10px;
  margin: 5px 0;
  border-radius: 8px;
  width: fit-content;
  border: 1px solid #000;
  max-width: 90%;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}
.message-item {
  margin-bottom: 15px;
}
.meta {
  font-size: 0.75em;
  color: #aaa;
  margin-bottom: 5px;
}
.delete-btn {
  font-size: 0.7em;
  color: red;
  background: none;
  border: none;
  cursor: pointer;
  margin-top: 5px;
}
.text {
  word-break: break-word;
  font-size: 1em;
}
.send {
  display: flex;
}
#input {
  flex: 1;
  padding: 10px;
  font-size: 1em;
  width: 1000px;
  border: 1px solid #ccc;
  border-radius: 4px;
  margin-right: 10px;
}
#sendButton {
  padding: 15px 20px !important;
  font-size: 30px !important;
  width: 105px;
  height: 70px;
}
</style>

  <div style="margin: 10px 0;">
  <strong>現在のオンライン人数：</strong>
  <span id="userCount">0</span>人
</div>
  <div id="adminUserList" style="margin: 10px 0;">
    <strong>オンラインユーザー一覧（管理者専用）：</strong>
    <ul id="userList"></ul>
  </div>
<div id="chat-container">
<div id="messages"></div>
  <h2><textarea class="chatText" id="input" maxlength="100" autocomplete="off" placeholder="最大100文字"></textarea></h2>
  <div class="send">
    <button class="blueButton30" id="sendButton" onclick="sendChat()">送信</button>
    <label style="font-size: 16px; font-weight: bold; padding-left: 10px;">
      <input type="checkbox" id="enterToggle">Enterで送信</label>
  </div>
<br>
</div>
</div> <!-- headerにある<div class="main"> を閉じているので正常です -->

<script src="/socket.io/socket.io.js"></script>
<script>
  function getCookie(name) {
    const cookies = document.cookie.split(';').map(c => c.trim());
    for (const cookie of cookies) {
      if (cookie.startsWith(name + '=')) {
        return decodeURIComponent(cookie.substring(name.length + 1));
      }
    }
    return null;
  }

  const isAdmin = getCookie('isAdmin') === "true";
  const username = getCookie("user");
  const socket = io({
    auth: { username: username || 'username error' }
  });

  if (isAdmin) {
    const adminDiv = document.getElementById("adminUserList");
    if (adminDiv) {
      adminDiv.style.display = "flex";
    } else {
      adminDiv.style.display = "none";
    }
  }
  
  function setCookie(name, value, days) {
    const expires = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toUTCString();
    document.cookie = name + '=' + encodeURIComponent(value) + '; expires=' + expires + '; path=/';
  }
  
  let messages;
  window.addEventListener('DOMContentLoaded', () => {
    const enterToggle = document.getElementById('enterToggle');
    const inputEl = document.getElementById('input');
    messages = document.getElementById('messages');
    
    const saved = getCookie("enterToSend");
    if (saved === "true") {
      enterToggle.checked = true;
      inputEl.placeholder = "最大100文字、Enterで送信、Shift+Enterで改行";
    } else {
      inputEl.placeholder = "最大100文字、Shift+Enterで送信、Enterで改行";
    }
    
    enterToggle.addEventListener("change", () => {
      const isChecked = enterToggle.checked;
      setCookie("enterToSend", isChecked ? "true" : "false", 365);
      inputEl.placeholder = isChecked
        ? "最大100文字、Enterで送信、Shift+Enterで改行"
        : "最大100文字、Shift+Enterで送信、Enterで改行";
    });

    inputEl.addEventListener("keydown", function (e) {
      const isEnter = e.key === "Enter";
      const toggle = enterToggle.checked;
      
      if (isEnter) {
        if (!toggle && e.shiftKey) {
          e.preventDefault();
          sendChat();
        } else if (toggle && !e.shiftKey) {
          e.preventDefault();
          sendChat();
        }
      }
    });
  });
  
  function sendChat() {
    const inputEl = document.getElementById("input");
    const message = inputEl.value.trim();
    if (message.length === 0) return;

    if (message === "/help") {
      inputEl.value = '';
      alert(
        `使用できるコマンド一覧\n\n` +
        `/b text/ → 太字表示\n` +
        `/i text/ → イタリック(斜体)表示\n` +
        `/#rrggbb text/ → 文字色変更（例: /#ff0000 赤/）\n` +
        `/サイズ text/ → 文字サイズ指定（5〜30px）\n` +
        `※ すべて「/」で閉じてください\n\n` +
        `/help → コマンド一覧を表示\n` +
        `/admin ユーザー名 → 管理者権限を付与(管理者か製作者のみ使用可能)\n\n`
      );
      return;
    }
    
    socket.emit('chat message', message);
    inputEl.value = '';
  }
  
  socket.on('connect', () => {
    socket.emit('join', username);
  });
  
  socket.on('user count', (count) => {
    const userCountEl = document.getElementById('userCount');
    if (userCountEl) userCountEl.textContent = count;
  });
  
  socket.on('user list', (userList) => {
    if (!isAdmin) return;
    const userListEl = document.getElementById('userList');
    if (userListEl) {
      userListEl.innerHTML = '';
      userList.forEach(user => {
        const li = document.createElement('li');
        li.textContent = user;
        userListEl.appendChild(li);
      });
    }
  });
  
function parseCommands(text) {
  function parseRecursive(str, start=0) {
    let result = '';
    let i = start;

    while (i < str.length) {
      if (str[i] === '/') {
        // コマンド検出 (例: /b 、 /30 、 /#ff0000 )
        const cmdMatch = str.slice(i).match(/^\/(b|i|\d{1,2}|#[0-9a-fA-F]{6})\s/);
        if (!cmdMatch) {
          // コマンドでなければ単なるスラッシュとして追加
          result += '/';
          i++;
          continue;
        }

        const cmd = cmdMatch[1];
        const cmdLen = cmdMatch[0].length; // 例: "/b "は3文字

        i += cmdLen; // コマンド部分を読み飛ばす

        // 閉じスラッシュ1つまでをコマンドの範囲として取得
        let argStart = i;
        let argEnd = -1;
        while (i < str.length) {
          if (str[i] === '/') {
            argEnd = i;
            break;
          }
          i++;
        }

        if (argEnd === -1) {
          // 閉じスラッシュがない＝不正な構文なので残り全部追加して終了
          result += str.slice(start);
          return [result, str.length];
        }

        let innerText = str.slice(argStart, argEnd);
        i = argEnd + 1; // 閉じスラッシュの次へ

        // 再帰的に内部テキストをパース
        const [parsedInner] = parseRecursive(innerText, 0);

        // コマンドごとにHTML生成
        switch (true) {
          case cmd === 'b':
            result += `<strong>${parsedInner}</strong>`;
            break;
          case cmd === 'i':
            result += `<em>${parsedInner}</em>`;
            break;
          case /^\d+$/.test(cmd):
            const size = parseInt(cmd, 10);
            if (size < 5 || size > 30) {
              result += parsedInner;
            } else {
              result += `<span style="font-size:${size}px">${parsedInner}</span>`;
            }
            break;
          case /^#[0-9a-fA-F]{6}$/.test(cmd):
            result += `<span style="color:${cmd}">${parsedInner}</span>`;
            break;
          default:
            result += parsedInner;
        }
      } else {
        // 通常テキストを追加
        result += str[i];
        i++;
      }
    }

    return [result, i];
  }

  const [parsed] = parseRecursive(text, 0);
  return parsed;
}
  
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  function parseTextWithCommands(text) {
    const escaped = escapeHtml(text);
    return parseCommands(escaped);
  }
  
  function appendMessage(msg) {
    if (!msg || !msg.username || !msg.message || !msg.timestamp) return;
    const item = document.createElement('div');
    item.classList.add('message-item');
    
    item.innerHTML = `
      <div class="message-bubble">
        <div class="meta">
          <strong>${escapeHtml(msg.username)}</strong> [${escapeHtml(msg.timestamp)}]
        </div>
        <div class="text">${parseTextWithCommands(msg.message)}</div>
        ${(msg.username === username || isAdmin) ? `<button class="delete-btn" data-id="${msg.id}">削除</button>` : ''}
      </div>
    `;
    
    messages.appendChild(item);
    messages.scrollTop = messages.scrollHeight;
  }

  socket.on('chat history', (history) => {
    messages.innerHTML = '';
    history.forEach(msg => {
      if (msg && msg.username && msg.message && msg.timestamp) {
        appendMessage(msg);
      }
    });
  });

  socket.on('chat update', (msg) => {
    appendMessage(msg);
  });

  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('delete-btn')) {
      const id = e.target.getAttribute('data-id');
      const confirmed = confirm("本当にこのメッセージを削除しますか？");
      if (confirmed) {
        socket.emit('delete message', id, username);
      }
    }
  });

  socket.on('delete message', (id) => {
    const allMessages = document.querySelectorAll('.message-item');
    allMessages.forEach(item => {
      const button = item.querySelector('.delete-btn');
      if (button && button.getAttribute('data-id') === id) {
        item.remove();
      }
    });
  });

  socket.on('system message', (text) => {
    const item = document.createElement('div');
    item.classList.add('message-item');
    item.style.color = '#888';
    item.style.fontStyle = 'italic';
    item.textContent = `[システム] ${text}`;
    messages.appendChild(item);
    messages.scrollTop = messages.scrollHeight;
  });
</script>
<script src="/chat.js"></script>
<%- include("settings/footer") %>